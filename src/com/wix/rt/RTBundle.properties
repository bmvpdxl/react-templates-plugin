#Inspection suppression
unused.property.suppress.for.statement=Suppress for statement
unused.property.suppress.for.block=Suppress for block
unused.property.suppress.for.file=Suppress for file

#Inspections
rt.property.inspection.display.name=React Template Inspection
rt.inspection.group.name=Code quality tools
#rt.inspection.undefined.step.name=Undefined step
#rt.inspection.undefined.step.msg.name=Undefined step reference:
rt.property.inspection.message=rt: {0} ({1})

rt.rules.dir.does.not.exist=Rules directory not found. Path {0} not found in project
rt.rules.dir.is.not.a.dir=Rules path is not a directory. Path {0} not found in project

rt.directory.does.not.exist={0} directory not found. Path {1} not found in project
rt.directory.is.not.a.dir={0} path is not a directory. Path {1} not found in project
rt.file.does.not.exist={0} file not found. Path {1} not found in project
rt.file.is.not.a.file={0} path is not a file. Path {1} not found in project

properties.files.inspection.group.display.name=rt
rt.creating.file=Creating RT {0}

# documentation
doc.rt-repeat=<strong>rt-repeat</strong><br/>\
  Repeats a node with its subtree for each item in an array. This is implemented by creating a method that is passed to a map call as a callback. It creates a real context for the iterated variable. \
  The syntax is rt-repeat=\"itemVar in arrayExpr\". Within the scope of the element, itemVar will be available in javascript context, and also an itemVarIndex will be created to represent the index of the item. \
  If the definition is myNum in this.getMyNumbers(), than there will be 2 variables in the scope: myNum and myNumIndex. This naming is used to allow nesting of repeat expression with access to all levels.
doc.rt-scope=<strong>rt-scope</strong><br/>\
  This directive creates a new javascript scope. It actually creates a new method for this scope, and calls it with its current context. The syntax is rt-scope=\"expr1 as var1; expr2 as var2. \
  This gives a convenience method to shorten stuff up in a scope and make the code more readable. It also helps to execute an expression only once in a scope instead of every chunk that needs it.
doc.rt-class=<strong>rt-class</strong><br/>\
  In order to reduce the boiler-plate code when pragmatically setting class names, you can use the rt-class directive. \
  It expects to get a JSON object with keys as class names, and a value of true or false as the value. If the value is true, the class name will be included. \
  Please note the following: 1. In react templates, you can use the \"class\" attribute the same as you'd do in html. If you like, you can even have execution context within 2. \
  You cannot use class and rt-class on the same html element.
doc.rt-if=<strong>rt-if</strong><br/>\
  This gives you the ability to add conditions to a sub-tree of html. If the condition is evaluated to true, the subtree will be returned, otherwise, it will not be calculated. \
  It is implemented by a trinary expression.
doc.rt-props=<strong>rt-props</strong><br/>\
  This directive is used to inject properties to an element programmatically. It will merge the properties with the properties received in the template. \
  This option allows the code writer to build properties based on some app logic and pass them to the template. \
  It is also useful when passing properties set on the component to an element within the template. The expected value of this attribute is an expression returning an object. \
  The keys will be the properties and the values will be the property values.

action.gui.rt.text=RT File
action.gui.rt.description=Create a new RT file
error.cannot.create.rt=Cannot create RT File
command.create.rt=Create RT


rt.file=RT File
create.rt.file.0=Create RT file {0}
new.rt.file.title=New RT File
title.new.gui.form=New RT File
new.form.form.name.label=[new.form.form.name.label / messages/UIDesignerBundle]


